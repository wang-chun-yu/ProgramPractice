// This file is automatically generated by scxmlcc (version 0.10.1M-0f496bcb8b02fbc90108022464d5568136ee95e8)
// For more information, see http://scxmlcc.org

#ifndef SC_TIMER_SWITCH_INCLUDED
#define SC_TIMER_SWITCH_INCLUDED

#include <deque>
#include <vector>
#include <string>
#include <unordered_map>
#include <any>
#include <memory_resource>

class sc_timer_switch
{
	public:

	struct data_model;
	struct user_model;

	class state
	{
		public:
		virtual ~state(){}
		virtual state* event_button(sc_timer_switch&) { return 0; }
		virtual state* event_timer(sc_timer_switch&) { return 0; }
		virtual state* unconditional(sc_timer_switch&) { return 0; }
		virtual state* initial(sc_timer_switch&) { return 0; }

		template<class T> void enter(data_model&, ...) {}
		template<class T> void exit(data_model&, ...) {}
		virtual bool in(const void*) { return false; }
	};

	typedef state* (state::*event)(sc_timer_switch&);

	std::unordered_map<std::string, event> event_map;
	template<class C> class state_actions
	{
		protected:
		void enter(data_model&) {} // default enter action
		void exit(data_model&) {} // default exit action
	};

	template<class C, class P> class composite : public P, public state_actions<C>
	{
		virtual state* initial(sc_timer_switch&) { return 0; }
		public:
		typedef P parent_t;
		// LCA calculation
		template<class T> void enter(data_model&, composite*) {}
		template<class T> void enter(data_model &m, ...) { P::template enter<T>(m, static_cast<T*>(nullptr)); state_actions<C>::enter(m); }
		template<class T> void exit(data_model&, composite*) {}
		template<class T> void exit(data_model &m, ...) { state_actions<C>::exit(m); P::template exit<T>(m, static_cast<T*>(nullptr)); }
		static const void* id() { static const struct{} _id; return &_id; }
		bool in(const void *si) { return (si == id() || P::in(si)); }
	};

	class no_state {};
	enum transition_type { external, internal };

	template<event E, class S, class D0 = no_state> class transition_actions
	{
		protected:
		void enter(data_model&) {} // default enter action
		bool condition(data_model&) { return true; } // default condition action
	};

	// external/internal transition
	template<event E, class S, class D = no_state, transition_type T = external> class transition : public transition_actions<E, S, D>
	{
		template<transition_type I> struct id { };
		void state_enter(D* d, data_model &m, id<internal>, S*) { d->template enter<composite<S, typename S::parent_t> >(m); } // internal transition, where dst is descendant of src
		void state_enter(D* d, data_model &m, ...) { d->template enter<typename S::parent_t>(m); } // external transition, or dst is not descendant of src
		void state_exit(S*, data_model &, id<internal>, S*) {} // internal transition, where dst is descendant of src
		void state_exit(S* s, data_model &m, ...) { s->template exit<typename D::parent_t>(m); } // external transition, or dst is not descendant of src
		public:
		state* operator ()(S *s, sc_timer_switch &sc)
		{
			if(!transition_actions<E, S, D>::condition(sc.model)) return 0;
			D *d = sc.get_state<D>();
			state_exit(s, sc.model, id<T>(), static_cast<typename D::parent_t*>(nullptr));
			transition_actions<E, S, D>::enter(sc.model);
			state_enter(d, sc.model, id<T>(), static_cast<typename D::parent_t*>(nullptr));
			return d;
		}
	};

	// transition with no target
	template<event E, class S> class transition<E, S, no_state> : public transition_actions<E, S, no_state>
	{
		public:
		state* operator ()(S *s, sc_timer_switch &sc)
		{
			if(!transition_actions<E, S, no_state>::condition(sc.model)) return 0;
			transition_actions<E, S, no_state>::enter(sc.model);
			return s;
		}
	};

	private: bool dispatch_event(event e)
	{
		state *next_state;
		if ((next_state = (model.cur_state->*e)(*this))) model.cur_state = next_state;
		return !!next_state;
	}

	public: void dispatch_int(event e = &state::unconditional)
	{
		bool cont = dispatch_event(e) || dispatch_event(&state::unconditional);
		while (cont) {
			if ((cont = dispatch_event(&state::initial)));
			else if ((cont = dispatch_event(&state::unconditional)));
			else if (model.event_queue_int.size()) cont = dispatch_event(model.event_queue_int.front()), model.event_queue_int.pop_front(), cont |= !model.event_queue_int.empty();
			else break;
		}
	}

	void dispatch_ext()
	{
		while (!model.event_queue_ext.empty()) {
			dispatch_int(model.event_queue_ext.front());
			model.event_queue_ext.pop_front();
		}
	}

	void dispatch(event e = &state::unconditional)
	{
		model.event_queue_ext.push_back(e);
		if (model.event_queue_ext.size() == 1) do dispatch_ext(); while (!model.event_queue_ext.empty());
	}

	public: void dispatch(const std::string& ev_name, std::any data = std::any())
	{
		model._event.name = ev_name;
		model._event.data = data;
		auto event_it = event_map.find(ev_name);
		if(event_it != event_map.end()) {
			dispatch(event_it->second);
			return;
		}
		std::string name(ev_name);
		do {
			// name not found -> remove the last part and try again
			auto last_dot = name.rfind('.');
			if(last_dot == std::string::npos) break;
			name.erase(last_dot);
			event_it = event_map.find(name);
			if(event_it != event_map.end()) {
				auto ev = event_it->second;
				event_map[ev_name] = ev; // cache the event name
				dispatch(ev);
				return;
			}
		} while (! name.empty());
		// signal name not found or empty
		event_map[ev_name] = &state::unconditional; // cache the event name
		dispatch(&state::unconditional);
	}
	struct data_model
	{
		user_model *user;
		std::pmr::deque<event> event_queue_int;
		std::pmr::deque<event> event_queue_ext;
		state *cur_state;
		template <class S> bool In() { return cur_state->in(S::id()); }
		const std::string _sessionid;
		const std::string _name;
		struct EventStruct {
			std::string name;
			std::any data;
			void clear () { name.clear(); data = std::any(); };
		} _event;
		data_model(user_model* um, std::pmr::memory_resource* allocator)
		: user(um)
		, event_queue_int(allocator)
		, event_queue_ext(allocator)
		, _sessionid(std::to_string(reinterpret_cast<long long unsigned int>(this)))
		, _name("timer_switch")
		{}
	} model;

	sc_timer_switch(user_model *user = nullptr, std::pmr::memory_resource* allocator = std::pmr::get_default_resource())
	: event_map{{"button", &sc_timer_switch::state::event_button}, {"timer", &sc_timer_switch::state::event_timer}}
	, model(user, allocator)
	{
		model.cur_state = get_state<scxml>();
		model.event_queue_ext.push_back(&state::initial);
	}

	void init() { dispatch_ext(); }

	struct scxml : public composite<scxml, state>
	{
		state* initial(sc_timer_switch&sc) { return transition<&state::initial, scxml, state_off, internal>()(this, sc); }
	};

	struct state_off : public composite<state_off, scxml>
	{
		state* event_button(sc_timer_switch &sc) { return transition<&state::event_button, state_off, state_on>()(this, sc); }
	};

	struct state_on : public composite<state_on, scxml>
	{
		state* event_button(sc_timer_switch &sc) { return transition<&state::event_button, state_on, state_off>()(this, sc); }
		state* event_timer(sc_timer_switch &sc) { return transition<&state::event_timer, state_on>()(this, sc); }
		state* unconditional(sc_timer_switch &sc) { return transition<&state::unconditional, state_on, state_off>()(this, sc); }
	};

	template<class T> T* get_state()
	{
		static T t;
		return &t;
	}
};

#endif
